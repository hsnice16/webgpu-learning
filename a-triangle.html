<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A Triangle</title>
  </head>
  <body>
    <canvas id="canvas" width="640" height="480"></canvas>
  </body>
  <script id="shader" type="wgsl">
    struct VertexOutput {
      @builtin(position) clip_position: vec4<f32>,
    };

    @vertex
    fn vs_main(
      @builtin(vertex_index) in_vertex_index: u32,
    ) -> VertexOutput {
      var out: VertexOutput;
      let x = f32(1 - i32(in_vertex_index)) * 0.5;
      let y = f32(i32(in_vertex_index & 1u) * 2 - 1) * 0.5;
      out.clip_position = vec4<f32>(x, y, 0.0, 1.0);
      return out;
    }

    @fragment
    fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
      return vec4<f32>(1, 1, 1, 1.0);
    }
  </script>
  <script>
    async function webgpu() {
      let code = document.getElementById("shader").innerText;
      const shaderDesc = { code: code };

      const adapter = await navigator.gpu.requestAdapter();
      let device = await adapter.requestDevice();

      let shaderModule = device.createShaderModule(shaderDesc);

      const pipelineLayoutDesc = { bindGroupLayouts: [] };
      const layout = device.createPipelineLayout(pipelineLayoutDesc);

      const colorState = {
        format: "bgra8unorm",
      };

      const pipelineDesc = {
        layout,
        vertex: {
          module: shaderModule,
          entryPoint: "vs_main",
          buffers: [],
        },
        fragment: {
          module: shaderModule,
          entryPoint: "fs_main",
          targets: [colorState],
        },
        primitive: {
          topology: "triangle-list",
          frontFace: "ccw",
          cullMode: "back",
        },
      };

      let pipeline = device.createRenderPipeline(pipelineDesc);
      const context = canvas.getContext("webgpu");

      const canvasConfig = {
        device: device,
        format: navigator.gpu.getPreferredCanvasFormat(),
        usage: GPUTextureUsage.RENDER_ATTACHMENT,
        alphaMode: "opaque",
      };

      context.configure(canvasConfig);

      let colorTexture = context.getCurrentTexture();
      let colorTextureView = colorTexture.createView();

      let colorAttachment = {
        view: colorTextureView,
        clearValue: { r: 0, g: 0, b: 0, a: 1 },
        loadOp: "clear",
        storeOp: "store",
      };

      const renderPassDesc = {
        colorAttachments: [colorAttachment],
      };

      let commandEncoder = device.createCommandEncoder();

      let passEncoder = commandEncoder.beginRenderPass(renderPassDesc);
      passEncoder.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
      passEncoder.setPipeline(pipeline);
      passEncoder.draw(3, 1);
      passEncoder.end();

      device.queue.submit([commandEncoder.finish()]);
    }

    webgpu();
  </script>
</html>
