<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MipMaps</title>
  </head>
  <body>
    <canvas id="canvas" width="640" height="480"></canvas>
  </body>
  <script src="./toji-gl-matrix/gl-matrix.js"></script>
  <script id="mipmap-shader" type="wgsl">
    var<private> pos: array<vec2<f32>, 4> = array<vec2<f32>, 4>(
      vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
      vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

    struct VertexOutput {
      @builtin(position) position: vec4<f32>,
      @location(0) texCoord: vec2<f32>,
    };

    @vertex
    fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
      var output: VertexOutput;
      output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
      output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
      return output;
    }

    @group(0) @binding(0) var imgSampler: sampler;
    @group(0) @binding(1) var img: texture_2d<f32>;

    @fragment
    fn fs_main(@location(0) texCoord: vec2<f32>) -> @location(0) vec4<f32> {
      return textureSample(img, imgSampler, texCoord);
    }
  </script>
  <script id="shader" type="wgsl">
    @group(0) @binding(0)
    var<uniform> transform: mat4x4<f32>;
    @group(0) @binding(1)
    var<uniform> projection: mat4x4<f32>;

    struct VertexOutput {
      @builtin(position) clip_position: vec4<f32>,
      @location(0) tex_coords: vec2<f32>,
    };

    @vertex
    fn vs_main(
      @location(0) inPos: vec3<f32>,
      @location(1) inTexCoords: vec2<f32>
    ) -> VertexOutput {
      var out: VertexOutput;
      out.clip_position = projection * transform * vec4<f32>(inPos, 1.0);
      out.tex_coords = inTexCoords;
      return out;
    }

    @group(0) @binding(2)
    var t_diffuse: texture_2d<f32>;
    @group(0) @binding(3)
    var s_diffuse: sampler;

    @fragment
    fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
      return textureSample(t_diffuse, s_diffuse, in.tex_coords);
    }
  </script>
  <script>
    async function webgpu() {
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();

      const response = await fetch("./data/checkerboard.png");
      const blob = await response.blob();
      const imgBitmap = await createImageBitmap(blob);

      const textureDesc = {
        size: { width: imgBitmap.width, height: imgBitmap.height },
        format: "rgba8unorm",
        mipLevelCount: Math.ceil(
          Math.log2(Math.max(imgBitmap.width, imgBitmap.height))
        ),
        usage:
          GPUTextureUsage.COPY_DST |
          GPUTextureUsage.TEXTURE_BINDING |
          GPUTextureUsage.RENDER_ATTACHMENT,
      };

      const texture = device.createTexture(textureDesc);
      device.queue.copyExternalImageToTexture(
        { source: imgBitmap },
        { texture: texture },
        textureDesc.size
      );

      const mipmapCode = document.getElementById("mipmap-shader").innerText;
      const mipmapShaderDesc = { code: mipmapCode };
      const mipmapShaderModule = device.createShaderModule(mipmapShaderDesc);

      const mipmapUniformBindGroupLayout = device.createBindGroupLayout({
        entries: [
          {
            binding: 0,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {},
          },
          {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {},
          },
        ],
      });

      const mipmapPipelineLayoutDesc = {
        bindGroupLayouts: [mipmapUniformBindGroupLayout],
      };
      const mipmapLayout = device.createPipelineLayout(
        mipmapPipelineLayoutDesc
      );

      const mipmapPipelineDesc = {
        layout: mipmapLayout,
        vertex: {
          module: mipmapShaderModule,
          entryPoint: "vs_main",
        },
        fragment: {
          module: mipmapShaderModule,
          entryPoint: "fs_main",
          targets: [
            {
              format: texture.format,
            },
          ],
        },
        primitive: {
          topology: "triangle-strip",
          stripIndexFormat: "uint32",
        },
      };

      const mipmapPipeline = device.createRenderPipeline(mipmapPipelineDesc);
      let srcView = texture.createView({
        baseMipLevel: 0,
        mipLevelCount: 1,
      });
      const mipmapSampler = device.createSampler({ minFilter: "linear" });

      // Loop throught each mip level and renders the previous level's contents into it.
      let commandEncoder = device.createCommandEncoder({});

      for (let i = 1; i < textureDesc.mipLevelCount; ++i) {
        const dstView = texture.createView({
          baseMipLevel: i, // Make sure we're getting the right mip level...
          mipLevelCount: 1, // And only selecting one mip level
        });

        const passEncoder = commandEncoder.beginRenderPass({
          colorAttachments: [
            {
              view: dstView, // Render pass uses the next mip level as it's render attachment.
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              loadOp: "clear",
              storeOp: "store",
            },
          ],
        });

        // Need a separate bind group for each level to ensure
        // we're only sampling from the preview level.
        const bindGroup = device.createBindGroup({
          layout: mipmapUniformBindGroupLayout,
          entries: [
            {
              binding: 0,
              resource: mipmapSampler,
            },
            {
              binding: 1,
              resource: srcView,
            },
          ],
        });

        // Render
        passEncoder.setPipeline(mipmapPipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.draw(4);
        passEncoder.end();

        srcView = dstView;
      }

      device.queue.submit([commandEncoder.finish()]);

      const translateMatrix = glMatrix.mat4.lookAt(
        glMatrix.mat4.create(),
        glMatrix.vec3.fromValues(0, 100, 100),
        glMatrix.vec3.fromValues(0, 0, 0),
        glMatrix.vec3.fromValues(0.0, 0.0, 1.0)
      );

      const translateMatrixUniformBufferDesc = {
        size: translateMatrix.byteLength,
        usage: GPUBufferUsage.UNIFORM,
        mappedAtCreation: true,
      };

      const translateMatrixUniformBuffer = device.createBuffer(
        translateMatrixUniformBufferDesc
      );
      const translateMatrixUniformWriteArray = new Float32Array(
        translateMatrixUniformBuffer.getMappedRange()
      );
      translateMatrixUniformWriteArray.set(translateMatrix);
      translateMatrixUniformBuffer.unmap();

      const projectionMatrix = glMatrix.mat4.perspective(
        glMatrix.mat4.create(),
        1.4,
        640.0 / 480.0,
        0.1,
        1000.0
      );

      const projectionMatrixUniformBufferDesc = {
        size: projectionMatrix.byteLength,
        usage: GPUBufferUsage.UNIFORM,
        mappedAtCreation: true,
      };

      const projectionMatrixUniformBuffer = device.createBuffer(
        projectionMatrixUniformBufferDesc
      );
      const projectionMatrixUniformWriteArray = new Float32Array(
        projectionMatrixUniformBuffer.getMappedRange()
      );
      projectionMatrixUniformWriteArray.set(projectionMatrix);
      projectionMatrixUniformBuffer.unmap();

      const uniformBindGroupLayout = device.createBindGroupLayout({
        entries: [
          {
            binding: 0,
            visibility: GPUShaderStage.VERTEX,
            buffer: {},
          },
          {
            binding: 1,
            visibility: GPUShaderStage.VERTEX,
            buffer: {},
          },
          {
            binding: 2,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {},
          },
          {
            binding: 3,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {},
          },
        ],
      });

      const sampler = device.createSampler({
        addressModeU: "repeat",
        addressModeV: "repeat",
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "linear",
      });

      const uniformBindGroup = device.createBindGroup({
        layout: uniformBindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: {
              buffer: translateMatrixUniformBuffer,
            },
          },
          {
            binding: 1,
            resource: {
              buffer: projectionMatrixUniformBuffer,
            },
          },
          {
            binding: 2,
            resource: texture.createView(),
          },
          {
            binding: 3,
            resource: sampler,
          },
        ],
      });

      const pipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayout] };
      const layout = device.createPipelineLayout(pipelineLayoutDesc);

      const code = document.getElementById("shader").innerText;
      const shaderDesc = { code };
      const shaderModule = device.createShaderModule(shaderDesc);

      const positionAttribDesc = {
        shaderLocation: 0, // @location(0)
        offset: 0,
        format: "float32x3",
      };

      const positionBufferLayoutDesc = {
        attributes: [positionAttribDesc],
        arrayStride: 4 * 3, // sizeof(float) * 3
        stepMode: "vertex",
      };

      const positions = new Float32Array([
        800.0, -800.0, 0.0, 800.0, 800.0, 0.0, -800.0, -800.0, 0.0, -800.0,
        800.0, 0.0,
      ]);

      const positionBufferDesc = {
        size: positions.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true,
      };

      const positionBuffer = device.createBuffer(positionBufferDesc);
      const writeArray = new Float32Array(positionBuffer.getMappedRange());
      writeArray.set(positions);
      positionBuffer.unmap();

      const texCoordsAttribDesc = {
        shaderLocation: 1, // @location(1)
        offset: 0,
        format: "float32x2",
      };

      const texCoordsBufferLayoutDesc = {
        attributes: [texCoordsAttribDesc],
        arrayStride: 4 * 2, // sizeof(float) * 2
        stepMode: "vertex",
      };

      const texCoords = new Float32Array([
        20.0, 0.0,
        //
        20.0, 20.0,

        0.0, 0.0,

        0.0, 20.0,
      ]);

      const texCoordsBufferDesc = {
        size: texCoords.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true,
      };

      const texCoordsBuffer = device.createBuffer(texCoordsBufferDesc);
      const texCoordsWriteArray = new Float32Array(
        texCoordsBuffer.getMappedRange()
      );
      texCoordsWriteArray.set(texCoords);
      texCoordsBuffer.unmap();

      const colorState = {
        format: "bgra8unorm",
      };

      const pipelineDesc = {
        layout,
        vertex: {
          module: shaderModule,
          entryPoint: "vs_main",
          buffers: [positionBufferLayoutDesc, texCoordsBufferLayoutDesc],
        },
        fragment: {
          module: shaderModule,
          entryPoint: "fs_main",
          targets: [colorState],
        },
        primitive: {
          topology: "triangle-strip",
          frontFace: "ccw",
          cullMode: "none",
        },
      };

      const pipeline = device.createRenderPipeline(pipelineDesc);
      const context = canvas.getContext("webgpu");

      const canvasConfig = {
        device,
        format: navigator.gpu.getPreferredCanvasFormat(),
        usage: GPUTextureUsage.RENDER_ATTACHMENT,
        alphaMode: "opaque",
      };
      context.configure(canvasConfig);

      const colorTexture = context.getCurrentTexture();
      const colorTextureView = colorTexture.createView();

      const colorAttachment = {
        view: colorTextureView,
        clearValue: { r: 1, g: 0, b: 0, a: 1 },
        loadOp: "clear",
        storeOp: "store",
      };

      const renderPassDesc = { colorAttachments: [colorAttachment] };
      commandEncoder = device.createCommandEncoder();
      const passEncoder = commandEncoder.beginRenderPass(renderPassDesc);

      passEncoder.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, uniformBindGroup);
      passEncoder.setVertexBuffer(0, positionBuffer);
      passEncoder.setVertexBuffer(1, texCoordsBuffer);
      passEncoder.draw(4, 1);
      passEncoder.end();

      device.queue.submit([commandEncoder.finish()]);
    }

    webgpu();
  </script>
</html>
